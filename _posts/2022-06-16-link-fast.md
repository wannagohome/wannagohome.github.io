---
title: "[WWDC] Link 속도를 높여보자"
categories:
  - Build structure
tags:
  - build
  - xcode
published: true
---

<br/>

Linking 과정에서 일어나는 일에대해 알아봄으로써 어떻게 Linking 속도를 높일수 있는지 배워봅시다.

<br/>

# Linking 이란?

우리가 작성한 코드와 library나 framework와 같은 외부 의존성을 함께 사용하기 위해선 linker가 필요합니다. linking은 크게 두 가지 종류로 나뉘는데, 먼저 static linking은 build time에 일어나는데 build time과 app size에 영향을 주게 됩니다. 반면 dynamic linking은 앱이 실행될 때 일어나며, launch time에 영향을 주게 됩니다.

<br/>

# Static Linking

Static linking에 대해 더 자세히 알아보기 전에 과거로 돌아가 history를 살펴보도록 합시다.

![1](https://github.com/wannagohome/wannagohome.github.io/blob/master/assets/images/link_fast/1.png?raw=true)

옛날 옛적 프로그램은 매우 단순했습니다. 하나의 소스파일만이 있었고 그 소스파일을 컴파일해 실행가능한 프로그램을 만들기만 하면 되었죠. 하지만 시간이 지나면서 모든 소스코드를 한 파일에 몰아넣기엔 어렵게 되었고, 여러 파일이 필요하게 됩니다. 여러개의 소스파일은 어떻게 빌드해야 할까요?

소스파일을 나누고자 하는 시도는 단지 파일이 거대해 지는 것 뿐만이 아니라 모든 함수를 다시 컴파일 하는 것을 피하기 위해서 이기도 했습니다. 따라서 컴파일러를 두 부분으로 나누게 됩니다.

![2](https://github.com/wannagohome/wannagohome.github.io/blob/master/assets/images/link_fast/2.png?raw=true)
첫 번째 부분은 소스코드를 relocatable 한 object 라는 중간 파일로 컴파일 합니다. 그리고 두 번째 부분에서는 첫 번째의 결과물인 오브젝트 파일을 읽어 executable로 만듭니다. 그리고 여기서 두 번째 부분을 ld 혹은 static linker라고 부릅니다.

<br/>

![3](https://github.com/wannagohome/wannagohome.github.io/blob/master/assets/images/link_fast/3.png?raw=true)
소프트웨어가 발전함에 따라 사람들은 많은 .o(오브젝트) 파일을 만들어 사용했고, 점차 번거로워 지기 시작했습니다. 이 때 누군가가 "이 많은 오브젝트 파일들을 라이브러리로 패키징하는게 낫지 않을까?" 하는 생각을 떠올렸는데, 당시엔 'ar' 이라고 하는 파일들을 bundling 하는 아카이빙 도구가 표준처럼 사용되던 시기였습니다. 그러다 보니 workflow가 다음과 같이 변하게 되는데, 오브제젝트 파일들을 ar로 아카이브 하는 과정이 추가된 것입니다. 그리고 링커는 아카이브 파일에서 오브젝트 파일을 직접 읽어낼 수 있도록 개선되었습니다.

<br/>

이 방법은 공통의 코드를 공유하는 방법의 놀라운 발전이었습니다. 당시에 단순하게 archive혹은 library라도 불리우던 것이 지금은 static libarary라도 불리게 된것입니다.

하지만 라이브러리에 있는 수천개의 함수들이 그대로 복사되어 들어오면서 프로그램의 크기 또한 비대해졌습니다. 실제로는 그 많은 함수들 중 단 몇개만을 사용하는데 말이지요. 따라서 최적화 과정이 추가되게 됩니다. linker는 static library에 모든 오브젝트 파일을 끌어오지 않고 undefined symbol을 resolve 하는 경우에만 끌어오도록 하는 것입니다. 이는 개발자들이 C의 거대한 표준 라이브러리인 libc.a 를 동일하게 link하면서도 프로그램에 실제 필요한 부분만 사용할 수 있게 해주었습니다. 그리고 이 모델은 지금까지도 사용되고 있습니다.

하지만 앞서 설명한 '선택적 로딩'은 개발자들을 햇갈리게 할 때가 있어서, 분명한 이해를 돕기 위해 간단한 예시를 들어보겠습니다. 

![4](https://github.com/wannagohome/wannagohome.github.io/blob/master/assets/images/link_fast/4.png?raw=true)
main.c 파일에는 foo 함수를 호출하는 main 함수가 있습니다. foo.c 파일에는 bar 함수를 호출하는 foo 함수가 있습니다. bar.c 에는 bar 함수의 구현부가 있으며 사용되지 않는 함수인 unused 함수도 가지고 있습니다. 마지막으로 baz.c 에는 undef 함수를 호출하는 baz 함수가 있습니다.

<br/>

![5](https://github.com/wannagohome/wannagohome.github.io/blob/master/assets/images/link_fast/5.png?raw=true)
이제 이들 각각을 오브젝트 파일로 컴파일 해보겠습니다. foo, bar, undef 에는 회색 표시가 없네요. undefined symbol이기 때문입니다. undefinded symbol은 symbol의 정의 아닌 사용(참조)을 뜻합니다.

<br/>

![6](https://github.com/wannagohome/wannagohome.github.io/blob/master/assets/images/link_fast/6.png?raw=true)
이제 bar.o 와 baz.o 를 static library로 묶고, 나머지 두개의 오브젝트 파일과 static library를 link 해보겠습니다.

<br/>

![7](https://github.com/wannagohome/wannagohome.github.io/blob/master/assets/images/link_fast/7.png?raw=true)
linker는 command line order에 따라 동작합니다. 먼저 main.o 찾아 로드하고 main 함수의 정의를 찾습니다. symbol table에 올라가 있는게 보이시나요? 이때 main 함수만 찾는게 아니라 main 함수가 undefined 상태인 foo를 가지고 있다는 것 또한 찾게됩니다.

<br/>

![8](https://github.com/wannagohome/wannagohome.github.io/blob/master/assets/images/link_fast/8.png?raw=true)
linker는 command line의 다음 파일을 파싱하는데 여기에선 foo.o군요. foo.o는 foo함수의 정의를 가지고 있고 이는 foo가 더이상 undefined 상태가 아니게 된다는 것입니다. 여기서 멈추지 않고 foo.o를 로딩하면서 bar라는 undefined symbol이 추가됩니다.

<br/>

![9](https://github.com/wannagohome/wannagohome.github.io/blob/master/assets/images/link_fast/9.png?raw=true)
이제 command line에 있는 모든 오브젝트 파일들이 로드되었습니다. linker는 아직 남아있는 undefined symbol이 있는지 확인하는데 이 상황에선 bar가 되겠군요. 이제 linker는 남아있는 undefined symbol의 참조를 찾기 위해 command line의 라이브러리 들을 살펴보기 시작합니다. static library에서 bar symbol을 정의하고 있는 bar.o를 찾을 수 있군요. 이제 linker는 archive에서 bar.o를 로드합니다. 

<br/>

![10](https://github.com/wannagohome/wannagohome.github.io/blob/master/assets/images/link_fast/10.png?raw=true)
이 시점에서 더이상 남아있는 undefined symbol이 없으니 라이브러리를 읽는 것을 중단하고 다음 단계로 넘어갑니다. 프로그램에 포함될 모든 함수와 데이터에 주소를 할당하는 것입니다. 그리고 나서 모든 함수와 데이터들을 output 파일로 복사합니다.

<br/>

![11](https://github.com/wannagohome/wannagohome.github.io/blob/master/assets/images/link_fast/11.png?raw=true)
드디어 최종 결과물인 프로그램이 나왔습니다. baz.o는 분명 static library에 있지만 프로그램에는 포함되지 않았습니다. linker가 static library를 선택적으로 로드했기 때문입니다.

이제 static linking과 static library에 대해 알았으니 ld64라고 불리우는 애플의 static linker의 개선점에 대해 알아보겠습니다.

<br/>

# ld64 최적화

많은 요구에 따라 ld64 최적화 작업을 진행했고, 올해 linker는 최대 2배의 속도를 내게 될것입니다. linker의 작업을 병렬적으로